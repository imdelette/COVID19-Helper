{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useOffsetX = void 0;\n\nvar _reactNativeReanimated = require(\"react-native-reanimated\");\n\nvar useOffsetX = function useOffsetX(opts, visibleRanges) {\n  var handlerOffsetX = opts.handlerOffsetX,\n      index = opts.index,\n      size = opts.size,\n      loop = opts.loop,\n      data = opts.data,\n      _opts$type = opts.type,\n      type = _opts$type === void 0 ? 'positive' : _opts$type,\n      _opts$viewCount = opts.viewCount,\n      viewCount = _opts$viewCount === void 0 ? Math.round((data.length - 1) / 2) : _opts$viewCount;\n  var ITEM_LENGTH = data.length;\n  var VALID_LENGTH = ITEM_LENGTH - 1;\n  var TOTAL_WIDTH = size * ITEM_LENGTH;\n  var HALF_WIDTH = 0.5 * size;\n  var positiveCount = type === 'positive' ? viewCount : VALID_LENGTH - viewCount;\n  var startPos = size * index;\n\n  if (index > positiveCount) {\n    startPos = (index - ITEM_LENGTH) * size;\n  }\n\n  var MAX = positiveCount * size;\n  var MIN = -((VALID_LENGTH - positiveCount) * size);\n  var x = (0, _reactNativeReanimated.useDerivedValue)(function () {\n    var _f = function _f() {\n      var _visibleRanges$value = visibleRanges.value,\n          negativeRange = _visibleRanges$value.negativeRange,\n          positiveRange = _visibleRanges$value.positiveRange;\n\n      if ((index < negativeRange[0] || index > negativeRange[1]) && (index < positiveRange[0] || index > positiveRange[1])) {\n        return Number.MAX_SAFE_INTEGER;\n      }\n\n      if (loop) {\n        var inputRange = [-TOTAL_WIDTH, MIN - HALF_WIDTH - startPos - Number.MIN_VALUE, MIN - HALF_WIDTH - startPos, 0, MAX + HALF_WIDTH - startPos, MAX + HALF_WIDTH - startPos + Number.MIN_VALUE, TOTAL_WIDTH];\n        var outputRange = [startPos, MAX + HALF_WIDTH - Number.MIN_VALUE, MIN - HALF_WIDTH, startPos, MAX + HALF_WIDTH, MIN - HALF_WIDTH + Number.MIN_VALUE, startPos];\n        return (0, _reactNativeReanimated.interpolate)(handlerOffsetX.value, inputRange, outputRange, _reactNativeReanimated.Extrapolate.CLAMP);\n      }\n\n      return handlerOffsetX.value + size * index;\n    };\n\n    _f._closure = {\n      visibleRanges: visibleRanges,\n      index: index,\n      loop: loop,\n      TOTAL_WIDTH: TOTAL_WIDTH,\n      MIN: MIN,\n      HALF_WIDTH: HALF_WIDTH,\n      startPos: startPos,\n      MAX: MAX,\n      interpolate: _reactNativeReanimated.interpolate,\n      handlerOffsetX: handlerOffsetX,\n      Extrapolate: {\n        CLAMP: _reactNativeReanimated.Extrapolate.CLAMP\n      },\n      size: size\n    };\n    _f.asString = \"function _f(){const{visibleRanges,index,loop,TOTAL_WIDTH,MIN,HALF_WIDTH,startPos,MAX,interpolate,handlerOffsetX,Extrapolate,size}=jsThis._closure;{const{negativeRange:negativeRange,positiveRange:positiveRange}=visibleRanges.value;if((index<negativeRange[0]||index>negativeRange[1])&&(index<positiveRange[0]||index>positiveRange[1])){return Number.MAX_SAFE_INTEGER;}if(loop){const inputRange=[-TOTAL_WIDTH,MIN-HALF_WIDTH-startPos-Number.MIN_VALUE,MIN-HALF_WIDTH-startPos,0,MAX+HALF_WIDTH-startPos,MAX+HALF_WIDTH-startPos+Number.MIN_VALUE,TOTAL_WIDTH];const outputRange=[startPos,MAX+HALF_WIDTH-Number.MIN_VALUE,MIN-HALF_WIDTH,startPos,MAX+HALF_WIDTH,MIN-HALF_WIDTH+Number.MIN_VALUE,startPos];return interpolate(handlerOffsetX.value,inputRange,outputRange,Extrapolate.CLAMP);}return handlerOffsetX.value+size*index;}}\";\n    _f.__workletHash = 12723241758918;\n    _f.__location = \"/Users/zhaodonghao/code/github/react-native-reanimated-carousel/src/hooks/useOffsetX.ts (45:30)\";\n\n    global.__reanimatedWorkletInit(_f);\n\n    return _f;\n  }(), [loop, data, viewCount, type, size, visibleRanges]);\n  return x;\n};\n\nexports.useOffsetX = useOffsetX;","map":{"version":3,"mappings":"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","names":["useOffsetX","opts","visibleRanges","handlerOffsetX","index","size","loop","data","type","viewCount","Math","round","length","ITEM_LENGTH","VALID_LENGTH","TOTAL_WIDTH","HALF_WIDTH","positiveCount","startPos","MAX","MIN","x","value","negativeRange","positiveRange","Number","MAX_SAFE_INTEGER","inputRange","MIN_VALUE","outputRange","Extrapolate","CLAMP","_f","interpolate","global"],"sources":["useOffsetX.ts"],"sourcesContent":["import Animated, {\n    Extrapolate,\n    interpolate,\n    useDerivedValue,\n} from 'react-native-reanimated';\nimport type { IVisibleRanges } from './useVisibleRanges';\n\nexport interface IOpts {\n    index: number;\n    size: number;\n    handlerOffsetX: Animated.SharedValue<number>;\n    data: unknown[];\n    type?: 'positive' | 'negative';\n    viewCount?: number;\n    loop?: boolean;\n}\n\nexport const useOffsetX = (opts: IOpts, visibleRanges: IVisibleRanges) => {\n    const {\n        handlerOffsetX,\n        index,\n        size,\n        loop,\n        data,\n        type = 'positive',\n        viewCount = Math.round((data.length - 1) / 2),\n    } = opts;\n\n    const ITEM_LENGTH = data.length;\n    const VALID_LENGTH = ITEM_LENGTH - 1;\n    const TOTAL_WIDTH = size * ITEM_LENGTH;\n    const HALF_WIDTH = 0.5 * size;\n\n    const positiveCount =\n        type === 'positive' ? viewCount : VALID_LENGTH - viewCount;\n\n    let startPos = size * index;\n    if (index > positiveCount) {\n        startPos = (index - ITEM_LENGTH) * size;\n    }\n\n    const MAX = positiveCount * size;\n    const MIN = -((VALID_LENGTH - positiveCount) * size);\n\n    const x = useDerivedValue(() => {\n        const { negativeRange, positiveRange } = visibleRanges.value;\n        if (\n            (index < negativeRange[0] || index > negativeRange[1]) &&\n            (index < positiveRange[0] || index > positiveRange[1])\n        ) {\n            return Number.MAX_SAFE_INTEGER;\n        }\n\n        if (loop) {\n            const inputRange = [\n                -TOTAL_WIDTH,\n                MIN - HALF_WIDTH - startPos - Number.MIN_VALUE,\n                MIN - HALF_WIDTH - startPos,\n                0,\n                MAX + HALF_WIDTH - startPos,\n                MAX + HALF_WIDTH - startPos + Number.MIN_VALUE,\n                TOTAL_WIDTH,\n            ];\n\n            const outputRange = [\n                startPos,\n                MAX + HALF_WIDTH - Number.MIN_VALUE,\n                MIN - HALF_WIDTH,\n                startPos,\n                MAX + HALF_WIDTH,\n                MIN - HALF_WIDTH + Number.MIN_VALUE,\n                startPos,\n            ];\n\n            return interpolate(\n                handlerOffsetX.value,\n                inputRange,\n                outputRange,\n                Extrapolate.CLAMP\n            );\n        }\n\n        return handlerOffsetX.value + size * index;\n    }, [loop, data, viewCount, type, size, visibleRanges]);\n\n    return x;\n};\n"]},"metadata":{},"sourceType":"script"}